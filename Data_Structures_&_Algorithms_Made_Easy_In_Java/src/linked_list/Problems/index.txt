1. Implement Stack using Linked list
--> Stack_Using_Linked_List.java

2. Find nth node from the end of a linked list
== Brute force, start from every node, check if it takes n nodes to reach to last node (null)
   (n*n time, 1 space)
--> Nth_Node_From_The_End_1.java

3. Can we improve the complexity of Problem 2?
== used HashMap to store data in the nodes (n time, n space)
--> Nth_Node_From_The_End_2.java

4. Can we use Problem-3 approach for solving Problem-2 without creating the hash table?
== two scans, one for finding length, second for length-n traversal (n+n time 1 space)
--> Nth_Node_From_The_End_3.java

5. Can we solve Problem-2 in one scan ?
== sliding window with the help of 2 pointers (n time 1 space)
--> Nth_Node_From_The_End_4.java

6. Can we solve Problem-5 with recursion ?
== Using a global variable to track the length of the linked list
--> Nth_Node_From_The_End_5.java

7. Check whether the given linked list is either NULL-terminated or ends in a cycle(cyclic)?
== (Brute Force) Check with each node if the next pointer of some other node points to that node.
(This might take the code in an infinite loop) (would take n*n time, and 1 space)

8. Can we use hashing technique for solving Problem-8?
== Traverse through the whole linked list, while doing so, keep on saving the address of each of the node. Whenever we jump 
on the next node, search if next node's address exists in the HashMap. If it does, then the linked list is cyclic.
--> Cyclic_Linked_List_1.java

9. Can we solve the Problem-6 using sorting technique?
== Nope. We could store all the nodes in a list, sort it and check if any 2 adjacent members of the list are the same, then 
it is a cyclic linked list, but this approach may go in an infinite loop, so this one fails. (wud take nlogn time, & n space)

10. Can we solve the Problem-6 in O(n)?
== Yes, using two pointers(fast and slow)  (Floyd's Cycle Finding Algorithm)
--> Cyclic_Linked_List_2.java

11. You are given a pointer to the first element of a linked list L. There are 2 possibilites for L, it either ends(snake)
or its last element points back to one of the earlier elements in the list(snail). Task is to devise an algorithm that tests
whether a given list L is a snake or a snail.
(Tricky problem, same as Floyd's algorithm)
--> Cyclic_Linked_List_2.java

12. Check whether the given linked list is either NULL-terminated or not. If there is a cycle, find the start node of the loop.
== Find the loop, using Floyd's cycle detection algorithm, let fast ptr stay there, point slow pointer to the head of the 
linked list, make fast and slow pointer move by one at a time. They will meet at the beginning of the loop.
--> Start_Of_The_Loop_Linked_List.java

13. Prove that they'll meet at the start of the linked list
==
LEGEND:
i    <-- steps taken by slow pointer
2*i  <-- steps taken by fast pointer
m    <-- length of the non loop part
k    <-- distance between start of the loop and the position where pointers meet
l    <-- length of the loop part

i = m + a*l + k     // a = no. of rounds slow pointer has run in the loop
2*i = m + b*l + k   // b = no. of rounds fast pointer has run in the loop

.'. 2(m + a*l + k) = m + b*l + k
    2m + 2a*l + 2k = m + b*l + k
    2m + 2k - m - k = b*l - 2a*k
    
    m + k = (b - 2a)*l
    
    Hence we can say that, m+k = multiple of length of the loop
    
14. Will Floyd's algorithm work for 2,3 speeds of slow and fast pointers respectively ?
== It will work for any speeds of fast pointers (except 0 & same speeds of pointers)

15. Check whether the given linked list is NULL terminated. If there is a cycle, find the length of the loop
== floyd's algorithm for loop detection, a variable to track count of number of steps of the slow pointer
--> Cyclic_Linked_List_Length.java

16. Insert a node in a sorted linked list
--> Insert_In_A_Sorted_Linked_List.java

17. Reverse a singly linked list
--> Reverse_A_Linked_List_1.java <-- Iterative
--> Reverse_A_Linked_List_2.java <-- Recursive

18. Find intersection point of the given two linked lists
==  Brute force:
   Start with A, compare next of each Node in B with A's next node  
   O(mn) time complexity where m, n = length of linked list A and B respectively
   O(1) space complexity
   
       A-XXXXX
           XXXXX
               XXXXX
                   XXXX
                       XXX
                          OXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                        XX
                      XX
                    XXX
                 XXX
              XXX
           XXX
       XXXX
B-XXXXXX

19. Can Problem-18 be be done using a sorting technique?
== Nope

20. Can we solve Problem-18 using hash table?
--> Intersection_Of_Linked_Lists_1.java

21. Can we use stacks for solving the problem-18?
--> Intersection_Of_Linked_Lists_2.java

22. Is there any other way of solving Problem-18?
--> Intersection_Of_Linked_Lists_3.java

23. Can we still think of an alternative solution for the problem 18?
--> Intersection_Of_Linked_Lists_4.java

24. Can we improve the complexity for the problem-18?
--> Intersection_Of_Linked_Lists_5.java

25. How will you find the middle of the linked list?
--> Middle_of_the_linked_list_1.java

26. Can we improve the complexity of Problem-25?
--> Middle_of_the_linked_list_2.java

27. Can we use hash table for solving problem-25?
--> Middle_of_the_linked_list_3.java

28. Can we solve Problem 25 in just one scan ?
--> Middle_of_the_linked_list_4.java

29. How will you display a linked list from the end? (Display in reverse)
--> Print_In_Reverse_Recursive.java

30. Check whether the given linked list length is even or odd?
--> List_Length_Even_Odd.java

31. If the head of a linked list is pointing to kth element, then how will you get the elements before kth element ?
--> SKIPPED (Need to learn XOR linked lists)

32. Given two sorted linked lists, we need to merge them into the third list in sorted order.
--> Merge_Sorted_Linked_List_1.java

33. Can we solve Problem 32 without recursion?
--> Merge_Sorted_Linked_List_2.java

34. Reverse the linked list in pairs. If you have a linked list that holds 1-2-3-4-x, then after the function has been called
the linked list would hold 2-1-4-3-x
--> Flip_Pairs_Linked_List.java

35. Given a binary tree convert it to doubly linked list.
--> SKIPPED (Need to learn Trees first)

36. How do we sort the linked lists?
--> SKIPPED (Need to learn Sorting first)

37. Which of the following will give O(1) Complexity for concatenation?
    1. Singly linked list     2. doubly linked list     3. Circular linked list
--> Circular linked list, as we don't need to traverse to the end

38. Cut a circular linked list into 2 equal parts. If the number of nodes in the list are odd, then make first list longer.
--> Cut_Circular_Linked_List.java
   (NEED TO REVIEW AGAIN)
   
39. Palindrome check in a linked list.
--> Palindrome_Linked_List.java

40. Exchange the adjacent elements in linked list.
--> Exchange_Adjacent_Nodes.java

41. For a given K value (K > 0) reverse blocks of K nodes in a list.
--> Reverse_K_Nodes.java